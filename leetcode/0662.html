<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0662. Maximum Width of Binary Tree | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0662. Maximum Width of Binary Tree" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="https://leetcode.com/problems/maximum-width-of-binary-tree" />
<meta property="og:description" content="https://leetcode.com/problems/maximum-width-of-binary-tree" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-14T19:09:20+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0662. Maximum Width of Binary Tree" />
<script type="application/ld+json">
{"url":"/leetcode/0662.html","@type":"BlogPosting","headline":"Leetcode 0662. Maximum Width of Binary Tree","dateModified":"2021-08-14T19:09:20+02:00","datePublished":"2021-08-14T19:09:20+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0662.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"https://leetcode.com/problems/maximum-width-of-binary-tree","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/tree"><code class="highligher-rouge"><nobr>tree</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/dfs"><code class="highligher-rouge"><nobr>dfs</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/bfs"><code class="highligher-rouge"><nobr>bfs</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0662. Maximum Width of Binary Tree</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-08-14T19:09:20+02:00" itemprop="datePublished">
        Aug 14, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://leetcode.com/problems/maximum-width-of-binary-tree"> <font color="blue">https://leetcode.com/problems/maximum-width-of-binary-tree</font></a></p>

<p>In this problem we need to find maximum width of binary tree, so we need to use some tree traversal algorithm. BFS or DFS? I prefer to use <strong>BFS</strong>, because it emulate level by level traversal. While we traverse we need to keep some information about our node: its <code class="language-plaintext highlighter-rouge">level</code>, but also its <code class="language-plaintext highlighter-rouge">num</code>, which is number in level if this level was full. So, let us keep 3 informations for each node: <code class="language-plaintext highlighter-rouge">[num, level, node]</code>. How we change this information, when we traverse tree? We increase level by <code class="language-plaintext highlighter-rouge">1</code>, and for <code class="language-plaintext highlighter-rouge">num</code>, for left children we evaluate <code class="language-plaintext highlighter-rouge">2*num</code> and for the right we evaluate <code class="language-plaintext highlighter-rouge">2*num + 1</code>.  You can see how it works on the following tree (here in brackets I show 2 numbers : <code class="language-plaintext highlighter-rouge">[num, level]</code>. For example for node with <code class="language-plaintext highlighter-rouge">[num, level] = [5, 3]</code>, left children will have <code class="language-plaintext highlighter-rouge">[10, 4]</code> and right <code class="language-plaintext highlighter-rouge">[11, 4]</code>.</p>

<p><img src="https://assets.leetcode.com/users/images/38d6acca-03cc-4e3f-a95d-190af6757a82_1594280740.1000175.png" alt="image" /></p>

<p>So, we traverse our tree, using <strong>BFS</strong>, keep this information. Also we have <code class="language-plaintext highlighter-rouge">level_old</code> and <code class="language-plaintext highlighter-rouge">num_old</code> variable, which keep information for the first (the most left) node on each level, using this values we can understand if new level is started, and if started, we update it and for each new node we can evaluate current width of traversing layer.</p>

<p><strong>Complexity</strong>: time complexity is <code class="language-plaintext highlighter-rouge">O(n)</code>, where <code class="language-plaintext highlighter-rouge">n</code> is number of nodes, because we traverse our tree, using bfs. Space complexity is <code class="language-plaintext highlighter-rouge">O(w)</code>, where <code class="language-plaintext highlighter-rouge">w</code> is the biggest number of nodes in level, because we need to keep our queue. Potentially it is equal to <code class="language-plaintext highlighter-rouge">O(n)</code>. If we use <strong>DFS</strong>, then space complexity will be <code class="language-plaintext highlighter-rouge">O(h)</code>, where <code class="language-plaintext highlighter-rouge">h</code> is height of tree.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">widthOfBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="n">level_old</span><span class="p">,</span> <span class="n">num_old</span><span class="p">,</span> <span class="n">max_width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([[</span><span class="n">level_old</span><span class="p">,</span><span class="n">num_old</span><span class="p">,</span><span class="n">root</span><span class="p">]])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>    
            <span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="n">level_old</span><span class="p">:</span>
                <span class="n">level_old</span><span class="p">,</span> <span class="n">num_old</span> <span class="o">=</span> <span class="n">level</span><span class="p">,</span> <span class="n">num</span>
                
            <span class="n">max_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="n">num</span> <span class="o">-</span> <span class="n">num_old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>  <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>  <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">num</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">])</span>
                
        <span class="k">return</span> <span class="n">max_width</span>
</code></pre></div></div>

<p>If you like the solution, you can <strong>upvote</strong> it on leetcode discussion section:<a href="https://leetcode.com/problems/maximum-width-of-binary-tree/discuss/726732/python-10-lines-bfs-explained-with-figure"> <font color="blue">Problem 0662</font></a></p>

  </div><a class="u-url" href="/leetcode/0662.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>