<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0994. Rotting Oranges | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0994. Rotting Oranges" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="https://leetcode.com/problems/rotting-oranges" />
<meta property="og:description" content="https://leetcode.com/problems/rotting-oranges" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-14T19:09:20+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0994. Rotting Oranges" />
<script type="application/ld+json">
{"url":"/leetcode/0994.html","@type":"BlogPosting","headline":"Leetcode 0994. Rotting Oranges","dateModified":"2021-08-14T19:09:20+02:00","datePublished":"2021-08-14T19:09:20+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0994.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"https://leetcode.com/problems/rotting-oranges","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/bfs"><code class="highligher-rouge"><nobr>bfs</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0994. Rotting Oranges</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-08-14T19:09:20+02:00" itemprop="datePublished">
        Aug 14, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://leetcode.com/problems/rotting-oranges"> <font color="blue">https://leetcode.com/problems/rotting-oranges</font></a></p>

<p>This is graph traversal problem, so here we have a choise: to use <code class="language-plaintext highlighter-rouge">dfs</code> or to use <code class="language-plaintext highlighter-rouge">bfs</code>. What is asked: minimum number of minutes passed until there is no fresh orange. In graphs it means to find the greatest distance from rotten oranges to any other orange. Usually, if we need to find the distances, we use <code class="language-plaintext highlighter-rouge">bfs</code>. So, let me define my variables:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code> are dimensions of our <code class="language-plaintext highlighter-rouge">grid</code>, also we have <code class="language-plaintext highlighter-rouge">queue</code> to run our <code class="language-plaintext highlighter-rouge">bfs</code> and also we want to count number of fresh oranges: we need this to check in the end if all oranges become rotten or not.</li>
  <li>We put all rotten oranges coordinates to our <code class="language-plaintext highlighter-rouge">queue</code>, so we are going to start from all of them. Also we count number of fresh oranges.</li>
  <li>Define directions we can go: four of them and put <code class="language-plaintext highlighter-rouge">levels = 0</code>.</li>
</ol>

<p>Now, we traverse our <code class="language-plaintext highlighter-rouge">grid</code>, using <code class="language-plaintext highlighter-rouge">bfs</code>, using level by level traversal: it means, that each time, when we have some elements in <code class="language-plaintext highlighter-rouge">queue</code>, we popleft all of them and put new neighbours to the end. In this way each time we reach line <code class="language-plaintext highlighter-rouge">levels += 1</code>, we have nodes with distance which is <code class="language-plaintext highlighter-rouge">1</code> bigger than previous level. In the end <code class="language-plaintext highlighter-rouge">levels - 1</code> will be our answer, because one time in the end when we do not have anythin to add, <code class="language-plaintext highlighter-rouge">levels</code> still be incremented by one.</p>

<p>Finally, we check if we still have fresh oranges, and if yes, return <code class="language-plaintext highlighter-rouge">-1</code>. If not, we need to return <code class="language-plaintext highlighter-rouge">max(levels-1, 0)</code>, because it can happen, that our queue was empty in the beginning and we do not need to subtract <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p><strong>Complexity</strong>: time complexity is <code class="language-plaintext highlighter-rouge">O(mn)</code>, because we first traverse our grid to fill <code class="language-plaintext highlighter-rouge">queue</code> and found number of fresh oranges. Then we use classical <code class="language-plaintext highlighter-rouge">bfs</code>, so each node will be added and removed from <code class="language-plaintext highlighter-rouge">queue</code> at most <code class="language-plaintext highlighter-rouge">1</code> time. Space complexity is also can be <code class="language-plaintext highlighter-rouge">O(mn)</code>, we can have for example <code class="language-plaintext highlighter-rouge">O(mn)</code> rotten oranges in the very beginnig.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">orangesRotting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">fresh</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">deque</span><span class="p">(),</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">fresh</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="o">&lt;</span><span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">][</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">fresh</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">][</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">))</span>
                        
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">fresh</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">levels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>If you like the solution, you can <strong>upvote</strong> it on leetcode discussion section:<a href="https://leetcode.com/problems/rotting-oranges/discuss/781642/python-clean-bfs-solution-explained"> <font color="blue">Problem 0994</font></a></p>

  </div><a class="u-url" href="/leetcode/0994.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>