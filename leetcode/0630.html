<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0630. Course Schedule III | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0630. Course Schedule III" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Problem statement" />
<meta property="og:description" content="Problem statement" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-14T19:09:20+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0630. Course Schedule III" />
<script type="application/ld+json">
{"url":"/leetcode/0630.html","@type":"BlogPosting","headline":"Leetcode 0630. Course Schedule III","dateModified":"2021-08-14T19:09:20+02:00","datePublished":"2021-08-14T19:09:20+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0630.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Problem statement","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/greedy"><code class="highligher-rouge"><nobr>greedy</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/dp"><code class="highligher-rouge"><nobr>dp</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0630. Course Schedule III</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-08-14T19:09:20+02:00" itemprop="datePublished">
        Aug 14, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h4 id="problem-statement">Problem statement</h4>

<p><a href="https://leetcode.com/problems/course-schedule-iii/"> <font color="blue">https://leetcode.com/problems/course-schedule-iii/</font></a></p>

<h4 id="solution">Solution</h4>
<p>The clue idea, without which this problem is unsolvable, is then we always can change order of taken courses, such that their end times are increasing. It does not mean, that we need to take all the courses one by one, but there will always be order. For example if we have courses <code class="language-plaintext highlighter-rouge">1,2,3,4</code>, we can take <code class="language-plaintext highlighter-rouge">1,2,4</code> or <code class="language-plaintext highlighter-rouge">1,3,4</code> or something else, but it always will be subsequence of <code class="language-plaintext highlighter-rouge">1,2,3,4</code>. Note, that there is still <code class="language-plaintext highlighter-rouge">O(2^n)</code> options, so we are not able to check them all, so we need some additional idea.</p>

<p>One possible solution is to use dp with states <code class="language-plaintext highlighter-rouge">(i, time)</code>, where <code class="language-plaintext highlighter-rouge">i</code> means that we already considered first <code class="language-plaintext highlighter-rouge">i</code> courses (we take some of them and did not take some of them) and <code class="language-plaintext highlighter-rouge">time</code> means what moment of time it is now. Then on each step we can have two options: take course number <code class="language-plaintext highlighter-rouge">i</code> and do not take it. Overall time and space complexity is <code class="language-plaintext highlighter-rouge">O(n * d)</code>, where <code class="language-plaintext highlighter-rouge">n</code> is number of courses and <code class="language-plaintext highlighter-rouge">d</code> is maximum value of days we have.</p>

<p>Another approach is to try to use greedy approach, when we add new course. Let us consider courses one by one and our <strong>invariant</strong> after <code class="language-plaintext highlighter-rouge">k</code> courses will be pair <code class="language-plaintext highlighter-rouge">(N_k, T_k)</code>, where <code class="language-plaintext highlighter-rouge">N_k</code> is the maximum number of courses we can take and <code class="language-plaintext highlighter-rouge">T_k</code> is minimum time spend for taken courses. So, what happened, when we add <code class="language-plaintext highlighter-rouge">(k+1)</code>th course? If it fits, we just add it, so <code class="language-plaintext highlighter-rouge">N_{k+1} = N_k + 1</code> and <code class="language-plaintext highlighter-rouge">T_{k+1} = T_k + l_{k+1}</code>, where <code class="language-plaintext highlighter-rouge">l_{k+1}</code> is length of course number <code class="language-plaintext highlighter-rouge">k+1</code>. If it not fits, then it means, it is not possible to take <code class="language-plaintext highlighter-rouge">N_k+1</code> courses and we can take only <code class="language-plaintext highlighter-rouge">N_k</code>. However, we need to minimize <code class="language-plaintext highlighter-rouge">T_{k+1}</code> as well! So we have to get rid of one of the courses, such that we can fit <code class="language-plaintext highlighter-rouge">N_k</code> of them.</p>

<p>So, we already know that we can take at most <code class="language-plaintext highlighter-rouge">N_k</code> courses among first <code class="language-plaintext highlighter-rouge">k + 1</code> courses, the question is now which ones should be choose? The answer is that we need to choose courses with the smallest possible durations. As we sorted our courses by end times, on each step the set of avaliable courses we can take can only increase. So, we add courses one by one and if it happens that we can not fit them all, we need to get rid of the most heavy ones: with biggest duration.</p>

<h4 id="complexity">Complexity</h4>
<p>Time complexity is <code class="language-plaintext highlighter-rouge">O(n*log n)</code>, space is <code class="language-plaintext highlighter-rouge">O(n)</code>.</p>

<h4 id="code">Code</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">scheduleCourse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">courses</span><span class="p">):</span>
        <span class="n">heap</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">courses</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="n">t</span>
            <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">nt</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">+=</span> <span class="n">nt</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="remark">Remark</h4>
<p>If we do not use queue and just find each time longest course among <code class="language-plaintext highlighter-rouge">n</code>, we have <code class="language-plaintext highlighter-rouge">O(n^2)</code> complexity. We can optimize it to <code class="language-plaintext highlighter-rouge">O(n * m)</code>, where <code class="language-plaintext highlighter-rouge">m</code> is our total number of courses found, if we take into account that we need to look among only taken courses, not all of them.</p>

  </div><a class="u-url" href="/leetcode/0630.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>